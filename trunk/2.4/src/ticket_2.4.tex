\include{preamble}

\begin{document}
\ticket{2.4. Задачи комбинаторной оптимизации: о максимальном потоке, о паросочетании, о потоке минимальной стоимости.}
\section{Задача о максимальном потоке}

Рассмотрим граф из $n$ вершин. На его ребрах заданы пропускные
способности: $c(i, j)$ --- пропускная способность ребра из $i$ в $j$. 
Также выделены две вершины: $s$ --- исток и $t$ --- сток.

\begin{define}
    Потоком называется функция $f(i, j)$, удовлетворяющая условиям:

    \begin{enumerate}
    \item $f(i, j) \le c(i, j)$
    \item $f(i, j) = -f(j, i)$
    \item $\sum_{k=1}^{n} f(i, k) = 0$ для всех $i \notin \{s, t\}$
    \end{enumerate}
\end{define}

\begin{define}
    Величиной потока называется величина $F = \sum_{k=1}^{n} f(s, k) = \sum_{k=1}^{n} f(k, t)$
\end{define}

Задача: построить поток максимальной величины.

\begin{define}
    Остаточной пропускной способностью ребра называется величина $c'(i, j) = c(i, j) - f(i, j)$.
\end{define}

\begin{define}
    Остаточной сетью называется граф из ребер, для которых $c'(i, j) > 0$.
\end{define}

Если в остаточной сети есть путь из $s$ в $t$ (то есть есть $p_{1..k}$: $p_1=s$, $p_k=t$, 
$f(p_i, p_{i+1}) < c(p_i, p_{i+1}))$), то можно увеличить поток вдоль этого пути на 
$\Delta f = \min c(p_i, p_{i+1}) - f(p_i, p_{i+1})$.

\begin{theorem}
    Поток максимален $\Leftrightarrow$ В остаточной сети нет пути из $s$ в $t$.
\end{theorem}
\begin{proof}
    $\Rightarrow$. Если путь есть, то можно увеличить поток вдоль 
    ребер этого пути.
    $\Leftarrow$. Выделим множество вершин $S$, до которых есть путь из $s$,
    и множество $T$, до которых пути нет. Тогда $s \in S$, $t \in T$ и 
    все ребра из $S$ в $T$ насыщены ($f(i, j) = c(i, j)$). Таким образом,
    из $S$ в $T$ не может течь больше, чем сейчас.
\end{proof}

Таким образом получаем простой алгоритм: увеличивать поток вдоль какого-то пути остаточной
сети пока возможно. 

Если увеличивать вдоль произвольного пути, то алгоритм может
работать долго (если $c(i, j)$ целые, то зависит от них, если не целые, то
может вообще не сойтись). 

Модификации:
\begin{enumerate}
\item Увеличивать поток вдоль самого короткого пути. Работает за $O(nm^2)$.
\item (Алгоритм Диница). Сохраняем сеть обхода в ширину, чтобы быстро искать все короткие пути. Работает за $O(n^2m)$.
\item (Алгоритм Малхотры-Кумара-Махишвари). Так же, как в Динице, но быстрее находятся все короткие пути $O(n^3)$.
\end{enumerate}

\section{Задача о максимальном паросочетании}

\begin{define}
    Паросочетание --- это множество ребер, не имеющих общих концов. Величина паросочетания ---
    количество ребер в нем.
\end{define}

Задача: найти паросочетание максимальной величины.

Если граф не двудольный, то задача решается, но очень сложно, поэтому про это писать не будем.

Пусть граф двудольный: $n$ вершин слева, $n$ вершин справа, некоторые соединены ребрами.
Приделаем слева вершину-исток, справа --- вершину-сток. Ориентируем ребра слева направо
и сопоставим им пропускные способности, равные 1. Тогда поиск паросочетания
сводится к поиску потока (рис.~\ref{pic}). 

\begin{figure}
  \centering
  \includegraphics{pic.1} \hspace{3cm} \includegraphics{pic.2}
  \caption{Переход от паросочетания к потоку.}
  \label{pic}
\end{figure}

Таким образом, можно находить паросочетание за $O(nm)$ (величина паросочетания не больше $n$, поиск пути $O(m)$).

Модификация: Ищем пути длиной не больше $\sqrt{n}$ алгоритмом Диница, остальные (можно доказать, что их останется
не больше $\sqrt{n}$) обычным путем. Общее время работы $O(n\sqrt{m})$.

\section{Задача о максимальном потоке минимальной стоимости}

Добавим ребрам в задаче о потоке стоимости $p(i, j)$. 
\begin{define}
    Стоимостью потока называется величина $P = \sum_{i=1}^{n} \sum_{j=1}^{n} f(i, j) p(i, j)$
\end{define}

Задача: найти максимальный поток минимальной стоимости.

Решение: будем увеличивать поток каждый раз вдоль пути с минимальной стоимостью.
Можно доказать, что тогда получится поток минимальной стоимости.

\end{document}
